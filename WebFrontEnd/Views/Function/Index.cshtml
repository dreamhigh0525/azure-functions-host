@using WebFrontEnd.Controllers
@using RunnerInterfaces
@model FunctionInfoModel

@{
    ViewBag.Title = "Index";
    var trigger = Model.Descriptor.Trigger;
}

<div class="page-header">
<h1>@Model.Descriptor.Location.GetShortName() <small>@Model.Descriptor.Description</small></h1>
<p>Last Updated: @Model.Descriptor.Timestamp</p>
</div>

<div class="alert alert-info">
@if (trigger.ListenOnBlobs)
{
    <text>This function is invoked automatically when a new input blob becomes available.</text>
} else if (trigger.TimerInterval != null)
{
    <text>This function is invoked automatically on a timer at frequency (@trigger.TimerInterval)</text>
} else 
{
    <text>This function is not automatically invoked. You can invoke it explicitly via this webpage or via an HTTP RPC call.</text>
}
</div>

<h2>Invoke <small>the function with explicit arguments</small></h2>
@using (Html.BeginForm("InvokeFunctionWithArgs", "Function", FormMethod.Post, new { @class = "form-horizontal" }))
{
    <div class="hero-unit call-unit" id="invoke-unit">
        <div id="invoke-unit-body">
            <span id="invoke-unit-function">@(Model.Descriptor.Location.GetShortName())</span>
            @if(Model.Parameters.Length == 0) {
                <text>()</text>
            } else {
                <text>
                    (
                        <div id="invoke-unit-params">
                            <input type="hidden" value="@Model.Descriptor.ToString()" name ="func"/>
                            <input type="hidden" value="@Model.ReplayGuid" name ="replayGuid"/>
                            @for(int i =0; i < Model.Parameters.Length; i++) {
                                var param = Model.Parameters[i];
                                <div class="control-group">
                                    <label class="control-label" for="argValues[@i]">@param.Name:</label>
                                    <div class="controls">
                                        <input name="argValues[@i]" value="@param.ArgInvokeString" size="100" placeholder="@param.Description"/>
                                    </div>
                                </div>
                            }
                        </div>
                    )
                </text>
            }
        </div>
        <p class="call-unit-commands">
            <button type="submit" class="btn btn-primary"><i class="icon-play-sign"></i> Invoke</button>
        </p>
    </div>
}

@if(Model.KeyNames.Any()) {
    <h2>Bind <small>template parameters to the function arguments</small></h2>
    using (Html.BeginForm("ComputeArgsFromNames", "Function", FormMethod.Post, new { @class = "form-horizontal" }))
    {
        <div class="hero-unit call-unit" id="bind-unit">
            <div>
                <input type="hidden" value="@Model.Descriptor.ToString()" name ="func"/>
                @for (int i = 0; i < Model.KeyNames.Length; i++) { 
                    var key = Model.KeyNames[i];
                    <div class="control-group">
                        <label class="control-label" for="key[@i]">@key:</label>
                        <div class="controls">
                            <input name="key[@i]" size="100"/>
                        </div>
                    </div>
                }
            </div>
            <p class="call-unit-commands">
                <button type="submit" class="btn btn-primary"><i class="icon-signin"></i> Apply</button>
                <small>The function will <strong>NOT</strong> be invoked.</small>
            </p>
        </div>
    }
}

@Html.FunctionLogInvokeHistoryLink(Model.Descriptor.Location)

@*<h2>Explicitly invoke this function</h2>

<!-- mention the rest API . Even regenerate the link? -->

<p>To invoke this function, provide all of the parameters and submit. </p>
<p>Note that all azure storage locations are relative to the <b>@Utility.GetAccountName(Model.Descriptor.GetAccount())</b> storage container, since that's where the function was uploaded. </p>

@using (Html.BeginForm("InvokeFunctionWithArgs", "Function"))
{
    <input type="hidden" value="@Model.Descriptor.ToString()" name ="func"/>
    <input type="hidden" value="@Model.ReplayGuid" name ="replayGuid"/>
    
<table border="1">
    <tr>
        <td><b>name</b></td>
        <td><b>Description</b></td>
        <td><b>invoke with value:</b></td>
    </tr>

@for(int i =0; i < Model.Parameters.Length; i++)
{ 
    var param = Model.Parameters[i];
    <tr>
        <td>@param.Name</td>
        <td>@param.Description</td>
        <td bgcolor="#CCCCFF" >
            <input name="argValues[@i]" value="@param.ArgInvokeString" size="100"/>
        </td>
    </tr>
}
    </table>
    
    <input type="submit" value="Invoke this function with supplied values" />
}

<!-- Invoke w/ name parameters. This is the easiest case -->
@if (Model.KeyNames.Length > 0)
{
    <table border="1"><tr><td>
    <p>For convenience, you can provide named parameters to help fill out the invocation parameters:</p>    
        
    @using (Html.BeginForm("ComputeArgsFromNames", "Function"))
    {
        <input type="hidden" value="@Model.Descriptor.ToString()" name ="func"/>
    
        <table border="1">         
            <tr>
                <td>route value name</td>
                <td>value</td>
            </tr>
        @for (int i = 0; i < Model.KeyNames.Length; i++)        
        { 
        <tr>
            @{
            var key = Model.KeyNames[i];
            }
            <td>@(key) :</td>
            <td><input name="key[@i]" /> </td>
        </tr>
        }   
        </table>
        <input type="submit" value="Apply names to arguments (does not invoke)"/>
    }
    </td></tr></table>
}

<H3>Other actions:</H3>
<ul>
    <li>@Html.FunctionLogInvokeHistoryLink(Model.Descriptor.Location)</li>
</ul>*@